#include<iostream>
using namespace std;
int main() {
	int a[2], c, n0;
	cin >> a[0] >> a[1];
	cin >> c;
	cin >> n0;
	if (a[0] * n0 + a[1] <= c*n0 && a[0] <= c)   
		cout << 1;
	else
		cout << 0;
	return 0;
}
/*
 알고리즘의 소요 시간을 나타내는 O-표기법(빅-오)을 다음과 같이 정의하자.
O(g(n)) = {f(n) | 모든 n ≥ n(0)에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n(0)가 존재한다}
함수 f(n) = a(1)n + a(0), 양의 정수 c, n0가 주어질 경우 O(n) 정의를 만족하는지 알아보자.
-Input-
첫째 줄에 함수 f(n)을 나타내는 정수 a1, a0가 주어진다. (0 ≤ |a(i)| ≤ 100)
다음 줄에 양의 정수 c가 주어진다. (1 ≤ c ≤ 100)
다음 줄에 양의 정수 n0가 주어진다. (1 ≤ n(0) ≤ 100)
-Output-
f(n), c, n0가 O(n) 정의를 만족하면 1, 아니면 0을 출력한다.
-----------------------------------------------------------
f(n) = 7n + 7, g(n) = n, c = 8, n0 = 1이다. 
f(1) = 14, c × g(1) = 8이므로 O(n) 정의를 만족하지 못한다.
----------------------------------------------------------
f(n) = 7n + 7, g(n) = n, c = 8, n0 = 10이다. 모든 n ≥ 10에 대하여
7n + 7 ≤ 8n 이므로 O(n) 정의를 만족한다.

(a1 - c) * n <= -a0 을 이항해야하는데 a1>c 인 경우 부호가 바뀌지 않으므로
n<=-a0/(a1-c) 일 때 f(n) ≤ c × g(n)을 만족하게 됩니다.
이때 a0이 음수인 여부에 상관없이 모든 n ≥ n0에 대하여라는 
조건이 있기때문에 조건을 만족하지 못하는n ≥ n0이고,n>-a0/(a1-c) 인 수가 어딘가 존재합니다.

(a1 - c) n + a0 <= 0

기울기인 a1 - c 가 양수면 무슨 짓을 해도 불만족 합니다. n은 계속 커지니까요
기울기가 음수면 가장 작은 n인 n0를 대입 했을 떄 저 식이 만족해야 합니다
상수인 a0하고는 상관 없습니다.

코드에는 기울기가 양수일 때도 저 식을 만족할 수 있기에,
기울기가 양수면 무조건 0을 출력하게 만들면 됩니다.
기울기가 양수여도 제일 작은 n0에서 저 식을 만족할 수 있습니다.
단지 그 이상의 값에서 무조건 거짓이 될 뿐입니다.
*/